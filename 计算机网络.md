# 一、计算机网络基础

## 1.1 网络分层模型

### 1.1.1 OSI七层模型是什么？

**OSI 七层模型** 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：

![OSI 七层模型](https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png)

**OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。**

### 1.1.2 TCP/IP四层模型是什么？

**TCP/IP 四层模型** 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

![TCP/IP 四层模型](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png)

### 1.1.3 为什么网络要分层？

**复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。**

1. **各层之间相互独立**：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）**。这个和我们对开发时系统进行分层是一个道理。**

2. **提高了整体灵活性** ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。**这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。**

3. **大问题化小** ： 分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 **这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。**

## 1.2 常用网络协议

### 1.2.1 应用层有哪些常用的协议？

![应用层常见协议](https://oss.javaguide.cn/github/javaguide/cs-basics/network/application-layer-protocol.png)

### 1.2.2 传输层有哪些常用的协议？

![传输层常见协议](https://oss.javaguide.cn/github/javaguide/cs-basics/network/transport-layer-protocol.png)

### 1.2.3 网络层有哪些常用的协议？

![网络层常见协议](https://oss.javaguide.cn/github/javaguide/cs-basics/network/nerwork-layer-protocol.png)

# 二、HTTP

## 2.1 从输入URL到页面展示期间到底发生了什么？

1. DNS解析
2. 建立TCP连接
3. 发送HTTP/HTTPS请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. HTTP请求结束，断开TCP连接

## 2.2 打开一个网页，整个过程中会使用到哪些协议？

- DNS：获取域名对应的IP
- TCP：与服务器建立TCP连接
- IP：建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议
- OSPF：IP数据包在路由器之间，路由选择使用OSPF协议
- ARP：路由器与服务器通信时，需要将IP地址转换为MAC地址
- HTTP：在TCP建立连接后，使用HTTP协议访问网页

## 2.3 HTTP状态码有哪些？

![常见 HTTP 状态码](https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png)

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

- 「**100 Continue**」：表示正常，客户端可以继续发送请求。 
- 「**101 Switch Protocols**」： 切换协议，服务器根据客户端的请求切换协议。

`2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

- 「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

`3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

​	注：301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称**缓存重定向**，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

`4xx` 类状态码表示**客户端**发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个**笼统**的错误。
- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于**服务器端**的错误码。

- 「**500 Internal Server Error**」与 400 类型，是个**笼统**通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“<u>即将开业，敬请期待</u>”的意思。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“<u>网络服务正忙，请稍后重试</u>”的意思。

## 2.4 HTTP和HTTPS有什么区别？

- **端口号**：HTTP默认端口号是80，HTTPS默认端口号是443。
- **URL前缀**：HTTP的前缀是`http://`，HTTPS的前缀是`https://`。
- **安全性和资源消耗**：HTTP协议运行在TCP之上，所有的传输内容都是明文，客户端和服务端都无法验证对方身份。HTTPS是运行在SSL/TLS之上，所有的传输内容都是进过加密，加密采用对称加密，但对称加密的密钥用服务器方的整数进行非对称加密。所以说HTTP的安全性没有HTTPS高，但是HTTPS比HTTP消耗更多的服务器资源。
- **搜索引擎优化**：搜索引擎通常会更青睐使用HTTPS协议的网站，因为HTTPS能提供更高的安全性和用户隐私保护。

## 2.5 HTTP/1.0和HTTP/1.1有什么区别？

![HTTP/1.0 和 HTTP/1.1 对比](https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.0-vs-http1.1.png)

- **连接方式**：1.0为短连接，1.1支持长连接。
- **状态响应码**：1.1中加入了大量新的状态码，比如说`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移等。
- **缓存机制**：1.0中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，1.1中引入更多的缓存控制策略。
- **带宽**：1.0中存在浪费带宽的现象，比如说客户端只需要某个对象的一部分，而服务器将整个对象送过来了，还不支持断点续传的功能。1.1中在请求头中引入了range头域，允许只请求资源的某一部分。
- **Host头处理**：1.1引入了Host头字段，允许在同一IP地址上托管多个域名，从而支持虚拟主机的功能。而1.0没有该功能。

## 2.6 HTTP/1.1和HTTP/2.0有什么区别？

![HTTP/1.0 和 HTTP/1.1 对比](https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.1-vs-http2.0.png)

- **IO多路复用**：2.0在同一连接上可以同时传输多个请求和响应。而1.1使用串行方式，每个请求和响应都需要独立的连接。这使得2.0在处理多个请求时更高效，减少了网络延迟、提高了性能。
- **二进制帧**：2.0使用二进制帧进行数据传输，1.1使用文本格式报文。二进制帧更紧凑、高效，减少了传输的数据量和带宽消耗。
- **头部压缩**：1.1支持Body压缩，Header不支持压缩。2.0支持对Header的压缩，减少了网络开销。
- **服务器推送**：2.0支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少客户端的请求次数和延迟。而1.1需要自己发送请求获取相关资源。

## 2.7 HTTP/2.0和HTTP/3.0有什么区别？

![HTTP/2.0 和 HTTP/3.0 对比](https://oss.javaguide.cn/github/javaguide/cs-basics/network/http2.0-vs-http3.0.png)

- **传输协议**：2.0是基于TCP协议实现的，3.0新增了QUIC协议来实现可靠传输，提供与TLS/SSL相当的安全性，具有较低的延迟。可以把QUIC看做UDP的升级。
- **连接建立**：2.0需要经过经典的TCP三次握手（一般是三个RTT)。由于QUIC的特性，3.0可以避免三次握手的延迟，允许第一次连接时发送数据（0个RTT）。
- **队头阻塞**：2.0多请求复用一个TCP，一旦发生丢包就会阻塞所有HTTP请求。而3.0使用QUIC一定程度上解决了队头阻塞，一个连接建立多个不同的数据流，数据流之间互不影响。
- **错误恢复**：3.0有更好的错误恢复机制，当出现丢包、延迟等问题时，可以更快进行回复和重传。而2.0依赖于TCP的错误恢复机制。
- **安全性**：两者都支持加密通信，但是实现方式不同，2.0使用TLS进行加密，而3.0基于QUIC协议，包含了内置的加密和身份验证机制，安全性更强。

## 2.8 HTTP是不保存状态的协议，那么如何保存用户状态？

使用Session机制，Session的主要作用就是通过服务端记录用户状态。最典型的场景就是购物车，当需要向购物车中添加商品时，系统不知道是哪个用户操作的，因为HTTP协议是无状态的，所以服务器给特定的用户创建特定的Session之后，就可以标识这个用户并跟踪这个用户了。

在服务端保存Session的方式很多，最常用的就是内存和数据库（比如Redis）。

### 2.8.1 Session存在服务端，那如何实现Session的跟踪？

大多数情况下，通过Cookie中附加一个Session ID来进行跟踪。

### 2.8.2 如果Cookie被禁用怎么办？

最常用的方法就是利用URL重写把Session ID直接附加在URL路径的后面。

## 2.9 URI和URL的区别是什么？

- URI（Uniform Resource Identifier）：是统一资源标志符，可以唯一标识一个资源。
- URL（Uniform Resource Locator）：是同意资源定位符，可以提供该资源的路径。它是一种具体的URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。



## 2.10 Cookie和Session有什么区别？

- **存储位置不同**：Cookie存储在客户端的浏览器中，而Session存储在服务器。
- **存储内容不同**：Cookie中只能存储字符串类型的数据，而Session可以存储任何Java对象。
- **安全性不同**：Cookie中存储的信息可以被客户端查看和修改，而Session存储在服务器上，客户端无法查看和修改。
- **生命周期不同**：Cookie可以设置过期时间，而Session默认在客户端关闭浏览器后就会失效。
- **存储容量不同**：Cookie大小有限制，而Session存储容量较大，一般可以存储几MB的数据。

Cookie一般只能存储一些简单的用户信息，比如用户名、密码等；

Session用于在服务器存储一些复杂的对象信息，比如购物车、用户登录信息等。

# 三、PING

## 3.1 PING命令的作用是什么？

PING命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。

```bash
C:\Users\Acer>ping www.baidu.com

正在 Ping www.a.shifen.com [14.119.104.189] 具有 32 字节的数据:
来自 14.119.104.189 的回复: 字节=32 时间=33ms TTL=55
来自 14.119.104.189 的回复: 字节=32 时间=33ms TTL=55
来自 14.119.104.189 的回复: 字节=32 时间=33ms TTL=55
来自 14.119.104.189 的回复: 字节=32 时间=33ms TTL=55

14.119.104.189 的 Ping 统计信息:
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 33ms，最长 = 33ms，平均 = 33ms
```

## 3.2 PING命令的工作原理是什么？

PING 基于网络层的 **ICMP（Internet Control Message Protocol，互联网控制报文协议）**，其主要原理就是**通过在网络上发送和接收 ICMP 报文实现的**。

ICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：

- **查询报文类型** ：向目标主机发送请求并期望得到响应。
- **差错报文类型** ：向源主机发送错误信息，用于报告网络中的错误情况。

PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于**查询报文类型** 。

- PING 命令会向目标主机发送 ICMP Echo Request。
- 如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。

# 三、DNS

## 3.1 DNS的作用是什么？

DNS是域名管理系统，是当前用户浏览器访问网址之后，使用的第一个重要的协议。

DNS解决的是**域名和IP地址的映射问题。**

![DNS:域名系统](https://oss.javaguide.cn/github/javaguide/cs-basics/network/dns-overview.png)

在实际使用中，有一种情况下，浏览器是可以不必动用 DNS 就可以获知域名和 IP 地址的映射的。

浏览器在本地会维护一个`hosts`列表，一般来说浏览器要先查看要访问的域名是否在`hosts`列表中，如果有的话，直接提取对应的 IP 地址记录就好了。如果本地`hosts`列表内没有域名与IP 对应记录的话，那么 就需要用到DNS 。

目前 DNS 的设计采用的是分布式、层次数据库结构，**DNS 是应用层协议，基于 UDP 协议之上，端口为 53** 。

## 3.2 DNS服务器有哪些？

- **根DNS服务器**：根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。
- **顶级域DNS服务器（TLD服务器）**：顶级域是指域名的后缀，比如`com`、`org`、`net`、`edu`等等。顶级域服务器提供权威DNS服务器IP地址。
- **权威DNS服务器**：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。
- **本地DNS服务器**：每个互联网服务提供商都有一个自己本地DNS服务器。当主机发出DNS请求时，该请求被发往本地DNS服务器，起到代理的作用。

## 3.3 DNS解析的过程是什么样的？

1. 客户端首先发出一个DNS请求，问`www.server.com`的IP是啥，并发给本地的DNS服务器（也就是本地客户端的TCP/IP设置中填写的DNS服务器地址）。
2. 本地域名服务器收到客户端请求后，如果缓存的表格中能找到这个网址的IP地址，那么就直接返回IP地址；如果没有，则本地DNS会去问它的根域名服务器，这个网址的IP地址。根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3. 根DNS收到本地DNS请求后，发现网址后置是`.com`，则会告诉本地DNS这个网址归`.com`顶级域名服务器管理，并把这个顶级域名服务器的地址给本地DNS。
4. 本地DNS收到地址后，去询问顶级域名服务器，然后顶级域名服务器会给`www.server.com`区域的权威DNS服务器地址。
5. 本地DNS服务器去询问权威DNS服务器，权威DNS服务器查询到IP地址后，告诉本地DNS。
6. 本地DNS再将IP地址告诉客户端，客户端与目标建立连接。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679906088589-13a3ff6a-3f70-4d58-8c5b-5475e9c7eb68.png#averageHue=%23faf8f5&clientId=u687486a6-cbb7-4&from=paste&id=u12cfe1c1&name=image.png&originHeight=1095&originWidth=1505&originalType=url&ratio=1.100000023841858&rotation=0&showTitle=false&size=708614&status=done&style=none&taskId=u63393b04-efb6-4321-a1bc-dd203433432&title=)

# 四、TCP和UDP

## 4.1 TCP和UDP的区别

- **是否面向连接**：**UDP在传输数据之前不需要先建立连接**。**TCP在传输数据之前需要先建立连接**，传输结束后要释放连接。
- **是否可靠传输**：远程主机收到UDP报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达，也即**UDP的传输服务不可靠**。**TCP提供可靠的传输服务**，在传递数据之前通过三次握手建立连接，而且在传递数据时，有确认、窗口、重传、拥塞控制机制。通过TCP传输的数据无差错、不丢失、不重复并且按序到达。
- **是否有状态**：**UDP是无状态的服务**，也即不管发出去之后的事。**TCP传输是有状态的**，会记录自己发送消息的状态，比如是否发送、是否被接受等等。
- **传输效率**：由于TCP在传输时多了连接、确认、重传等机制，所以TCP的传输效率要比UDP低很多。
- **传输形式**：UDP是面向报文的，TCP是面向字节流的。
- **首部开销**：TCP首部开销（20-60字节）比UDP首部开销（8字节）要大。
- **是否提供广播或多播服务**：TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多。

|                        |     TCP     |    UDP     |
| :--------------------: | :---------: | :--------: |
|      是否面向连接      |     是      |     否     |
|        是否可靠        |     是      |     否     |
|       是否有状态       |     是      |     否     |
|        传输效率        |    较慢     |    较快    |
|        传输形式        |   字节流    | 数据报文段 |
|        首部开销        | 20 ~ 60字节 |   8字节    |
| 是否提供广播或多播服务 |     否      |     是     |

## 4.2 什么时候选择TCP，什么时候选择UDP？

- **UDP一般用于即时通信**，比如：语音、视频、直播等，这些场景对于传输数据的准确性要求不是特别高。
- **TCP用于对传输准确性要求特别高的场景**，比如文件传输、收发邮件、远程登录等。

## 4.3 HTTP是基于TCP还是UDP？

需要分版本讨论，在HTTP1.0、1.1、2.0中，是基于TCP协议的，而3.0中HTTP基于UDP的QUIC协议。

通过这个变化解决了2.0中的队头阻塞问题，同时还避免了TCP三次握手的延迟，允许在第一次连接时就发送数据。

## 4.4 使用TCP和UDP的协议分别有哪些？

### 4.4.1 使用TCP的协议

1. HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol)是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。
2. HTTPS：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议。
3. FTP：文件传输协议 FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。
4. SMTP：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，是一种用于发送电子邮件的协议。
5. POP3/IMAP：两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。
6. SSH：SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。

### 4.4.2 使用UDP的协议

1. DHCP：动态主机配置协议，动态配置 IP 地址
2. DNS：**域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。** 我们可以将其理解为专为互联网设计的电话薄。

## 4.5 TCP三次握手和四次挥手

### 4.5.1 说一说什么是三次握手？

建立一个TCP连接需要三次握手，缺一不可。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" style="zoom: 50%;" />

- **一次握手**：客户端发送带有SYN（SEQ=x）标志的数据包到服务器，然后客户端进入SYN_SEND状态，等待服务器的确认。
- **二次握手**：服务器发送带有SYN+ACK（SEQ=y，ACK=x+1）标志的数据包给客户端，然后服务器进入SYN_RECV状态。
- **三次握手**：客户端发送带有ACK（ACK=y+1）标志的数据包给服务器，然后客户端和服务器都进入ESTABLISHED状态，完成三次握手。

当完成三次握手之后，客户端和服务器之间就可以传输数据了。

### 4.5.2 为什么要进行三次握手？（为什么不是两次或四次握手？）

因为TCP采用的是**全双工**通信，进行三次握手的目的是建立可靠的通信信道，最主要的目的就是客户端和服务器双方确认自己与对方的发送和接收功能是正常的。

1. 第一次握手作用就是服务器确认：对方发送正常，自己接收正常。
2. 第二次握手作用就是客户端确认：自己发送、接收正常，对方发送、接收正常；服务器确认：对方发送正常、自己接受正常。
3. 第三次握手作用就是客户端确认：自己发送、接收正常，对方发送、接收正常；服务器确认：自己发送、接收正常，对方发送、接收正常。

三次握手就能刚好确认双方收发功能正常，缺一不可。

- 三次握手才可以阻止重复历史连接的初始化，防止旧的重复连接初始化造成混乱。
- 三次握手才可以同步双方的初始序列号。
- 三次握手才可以避免资源浪费。

### 4.5.3 第二次握手传回了ACK，为什么还要传回SYN？

服务器传回给客户端ACK是为了告诉客户端：“我收到的信息确实是你发的信息”，这表明客户端到服务器之间的通信是正常的，而传回SYN是为了建立并确认从服务器到客户端的通信正常。

### 4.5.4 说一说什么是四次挥手？

断开TCP连接需要四次挥手，缺一不可。

<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:50%;" />

- **第一次挥手**：客户端发送一个FIN（SEQ=x）标志的数据包给服务器，用来关闭客户端到服务器的数据传输。然后，客户端进入FIN-WAIT-1状态。
- **第二次挥手**：服务器收到这个FIN（SEQ=x）标志的数据包，它发送一个ACK（SEQ=x+1）标志的数据包给客户端。然后此时服务器进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。
- **第三次挥手**：服务器关闭与客户端之间的连接，并发送一个FIN（SEQ=y）标志的数据包给客户端，请求关闭连接，然后服务器进入LAST-ACK状态。
- **第四次挥手**：客户端发送ACK（SEQ=y+1）标志的数据包给服务器，并且进入TIME_WAIT状态，服务器在收到ACK（SEQ=y+1）标志的数据包后进入CLOSE状态。此时客户端等待2MSL后依然没有收到回复，就证明服务器已经正常关闭，随后客户端也就可以正常关闭了，也变成CLOSE状态。

只要四次挥手没有结束，客户端和服务器之间就可以继续传输数据。

### 4.5.5 为什么要四次挥手？

TCP 是**全双工**通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

比如，A和B打电话，即将结束时：

1. **第一次挥手**：A说：我没什么要说的了。
2. **第二次挥手**：B说：我知道了，但是B可能还有要说的话，A不能因为自己没什么要说的了就中断对话。
3. **第三次挥手**：B巴拉巴拉说了一通，B终于说：我说完了。
4. **第四次挥手**：A说：我知道了，这样双方都没什么说的了，对话才算结束。

### 4.5.6 为什么不把服务器发送的ACK和FIN合并，变成三次挥手？

因为服务器在收到客户端发送的断开连接请求时，可能还有一些数据没有发送完，所以这时候先发送ACK，表示收到了你要断开连接的请求。等我这些数据发完，再发送FIN，表示我数据发完了，可以断开连接了。

### 4.5.7 如果第二次挥手时，服务器的ACK没有送到客户端会发生什么？

客户端没有收到ACK确认，会重新发送FIN请求，继续第一次挥手的操作。

### 4.5.8 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？

第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，所以**一来一回需要等待 2 倍的时间**。 **2MSL时长** 这其实是相当于**至少允许报文丢失一次**。防止服务器没有收到 ACK 而不断重发 FIN。

## 4.6 TCP传输可靠性保障？

### 4.6.1 TCP如何保证传输的可靠性？

1. **基于数据块传输**：应用数据被分割成TCP认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。
2. **对失序数据包重新排序以及去重**：TCP为了保证不发生丢包，就给每个包一个序列号，有了序列号就能将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。
3. **校验和**：TCP将保持它首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
4. **超时重传**：当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。
5. **流量控制**：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。
6. **拥塞控制**：当网络拥塞时，减少数据的发送。

### 4.6.2 TCP如何实现流量控制？

**TCP利用滑动窗口实现流量控制。其目的是为了控制发送方发送数据的速率，保证接收方来得及接收。**接收方发送的确认报文中，窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0时，发送方不能发送数据。

### 4.6.3 为什么要进行流量控制？

双方在通信时，发送方的速率和接收方的速率不一定是相等的，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把数据存在**接收缓冲区**里。如果缓冲区满了，发送方还在发送数据的话，接收方只能把收到的数据包丢掉，浪费网络资源。所以要控制发送方的发送速率，让两者处于一种动态平衡。

**注意：发送方不等于客户端，接收端也不等于服务器。**

因为TCP是全双工通信，双方都可以进行双向通信。

### 4.6.4 发送窗口和接收窗口

#### 1.TCP发送窗口可以划分为四个部分

1. 已经发送并确认的TCP段；
2. 已经发送但没有确认的TCP段；
3. 未发送但接收方准备接收的TCP段；
4. 未发送并且接收方也不准备接收的TCP段；

![TCP发送窗口结构](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-send-window.png)

- **SND.WND** ：发送窗口。
- **SND.UNA**：Send Unacknowledged 指针，指向发送窗口的第一个字节。
- **SND.NXT**：Send Next 指针，指向可用窗口的第一个字节。

**可用窗口大小** = `SND.UNA + SND.WND - SND.NXT` 。

#### 2.TCP接收窗口可以划分为三个部分

1. 已经接收并且已经确认的TCP段；
2. 等待接收并且允许发送方发送TCP段；
3. 不可接收并且不允许发送方发送TCP段；

![TCP接收窗口结构](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-receive-window.png)

**接收窗口的大小是根据接收端处理数据的速度动态调整的。** 

### 4.6.5 TCP如何实现拥塞控制？

拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

![TCP的拥塞控制](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-congestion-control.png)

为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP 的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

- **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即**由小到大逐渐增大发送窗口**，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，**每经过一个传播轮次，cwnd 加倍。**

- **拥塞避免：** 拥塞避免算法的思路是**让拥塞窗口 cwnd 缓慢增大**，即**每经过一个往返时间 RTT 就把发送方的 cwnd 加 1**。

- **快重传与快恢复：** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

### 4.6.6 什么是ARQ协议？

**自动重传请求ARQ**是OSI模型中数据链路层和传输层的错误纠正协议之一。通过**确认**和**超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输。

如果发送方在发送后一段时间内没有收到确认信息，也即ACK，通常会重新发送，直到收到确认或者重试超过一定次数。

ARQ协议包括**停止等待ARQ协议**和**连续ARQ协议**。

1. 停止等待ARQ协议：为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。
2. 连续 ARQ 协议：可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

# 五、IP

## 5.1 IP协议的作用是什么？

**IP（Internet Protocol，网际协议）** 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是**定义数据包的格式**、**对数据包进行路由和寻址**，以便它们可以跨网络传播并到达正确的目的地。

目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用。

## 5.2 什么是IP地址？IP寻址如何工作？

每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 **IP 地址（Internet Protocol address）**，作为唯一标识符。每个 IP 地址都是一个字符序列，如 192.168.1.1（IPv4）、2001:0db8:85a3:0000:0000:8a2e:0370:7334（IPv6）。

当网络设备发送 IP 数据包时，数据包中包含了 **源 IP 地址** 和 **目的 IP 地址** 。

源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。这类似于一封邮件中同时包含了目的地地址和回邮地址。

网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。

这种基于 IP 地址的寻址方式是互联网通信的基础，它允许数据包在不同的网络之间传递，从而实现了全球范围内的网络互联互通。IP 地址的唯一性和全局性保证了网络中的每个设备都可以通过其独特的 IP 地址进行标识和寻址。

![IP 地址使数据包到达其目的地](https://oss.javaguide.cn/github/javaguide/cs-basics/network/internet_protocol_ip_address_diagram.png)







