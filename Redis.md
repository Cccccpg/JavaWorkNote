# 一、Redis基础

## 1.1 Redis有哪些优缺点？

### 1.1.1 优点

- **读写性能优异**。
- **支持数据持久化**，支持AOF和RDB两种持久化方式。
- **支持事务**，Redis的所有操作都是原子性的，同时还支持对几个操作合并后的原子性执行。
- 数据结构丰富，除了支持String类型的value外，还支持Hash、Set、ZSet、List等数据机构。
- **支持主从复制**，主机会自动将数据同步到从机，可以进行读写分离。

### 1.1.2 缺点

- **数据库容量**受到物理内存限制，不能用作海量数据的高性能读写，只适用于**较小数据量**的高性能操作和运算上。
- **Redis不具备自动容错和恢复功能**。
- 无法支持复杂查询。
- 数据容易丢失。
- **Redis较难支持在线扩容。**

## 1.2 Redis为什么这么快？

1. Redis是基于内存的，内存的访问速度是磁盘的上千倍；
2. Redis 基于 Reactor 模式设计开发了一套高效的**事件处理模型**，主要是**单线程事件循环**和 **IO 多路复用**；
3. Redis 内置了多种优化过后的数据结构实现，性能非常高。

## 1.3 为什么要用Redis？（为什么要用缓存？）

1. 高性能

   假如用户第一次访问数据库中的某些数据的话，是从硬盘中读取的，这个过程是比较慢。但是，如果用户访问的数据属于高频数据并且不会经常改变的话，可以将该用户访问的数据存在缓存中。这样保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。

2. 高并发

   直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存而不用经过数据库。进而，也就提高了系统整体的并发。

## 1.4 说一说Redis和Memcached的区别和共同点？

### 1.4.1 共同点

1. 都是基于内存的数据库，一般都用来当做缓存使用。
2. 都有过期策略。
3. 两者性能都非常高。

### 1.4.2 区别

1. **数据类型支持不同**， Memcached 仅支持简单的 key-value 结构的数据记录，Redis 支持的数据类型要丰富得多。最为常用的数据类型主要有五种：String、Hash、List、Set 和 Sorted Set。 
2. **内存管理机制不同**，在 Redis 中，并不是所有的数据都一直存储在内存中的。这是和 Memcached 相比一个最大的区别。当物理内存用完时，Redis 可以将一些很久没用到的 value 交换到磁盘。 
3. **数据持久化支持不同**，Redis 虽然是基于内存的存储系统，但是它本身是支持内存数据的持久化的，而且提供两种主要的持久化策略：RDB 快照和 AOF 日志。而 memcached 是不支持数据持久化操作的。 
4. **集群的管理不同**，Memcached 本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现 Memcached 的分布式存储。相较于 Memcached 只能采用客户端实现分布式存储，Redis 更偏向于在服务器端构建分布式存储。

## 1.5 说一说Redis中常用的缓存读写策略？

### 1.5.1 旁路缓存模式

适用于**请求比较多**的场景。

旁路缓存模式中服务端需要同时维系DB和Cache，并且以DB的结果为主。

**写：**

- 先更新DB；
- 然后直接删除Cache。

![img](https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-write.png)

**写：**

- 从Cache中读取数据，读取到就直接返回；
- Cache中读取不到的话，就从DB中读取数据返回；
- 再把数据放到Cache中。

![img](https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-read.png)

#### 在写数据的过程中，可以先删除Cache，然后再更新DB吗?

**不行！**因为这样可能会造成DB和Cache中的**数据不一致**的问题。

比如，请求1先把Cache中的A数据删除 -> 请求2从DB中读取数据 -> 请求1再把DB中的A数据更新。

#### 在写数据的过程中，可以先更新DB，然后再删除Cache吗？

理论上来说还是有可能出现数据不一致性的问题，不过概率比较小，因为Cache的写入速度比DB写入速度快很多。

比如，请求1从DB中读数据A -> 请求2更新DB中的数据A -> 请求1将数据A写入Cache。

**旁路缓存模式的缺点：**

1. 首次请求的数据一定不在Cache中。

   **解决方法：**可以将热点数据提前放入Cache中。

2. 写操作比较频繁的话会导致Cache中的数据会被频繁删除，这样会影响缓存的命中率。

   **解决方法：**

   - DB和Cache数据一致的情况下，同步更新DB和Cache，但需要加锁保证更新Cache时不存在线程安全问题。
   - DB和Cache数据不一致的情况下，同步更新DB和Cache，但是给Cache加一个比较短的过期时间。

### 1.5.2 读写穿透模式

该模式中服务端把Cache视为主要数据存储，从中读取数据并将数据写入其中，Cache负责将数据读取和写入DB。

**写穿透：**

- 先查Cache，Cache中不存在，直接更新DB；
- Cache中存在，则先更新Cache，然后Cache服务自己更新DB（同步更新Cache和DB）。

![img](https://oss.javaguide.cn/github/javaguide/database/redis/write-through.png)

**读穿透：**

- 从Cache中读取数据，读取到就直接返回；
- 读取不到的话，先从DB加载，写入到Cache后返回响应。

![img](https://oss.javaguide.cn/github/javaguide/database/redis/read-through.png)

### 1.5.3 异步缓存写入模式

与读写穿透模式类似，都是由Cache服务来负责Cache和DB的读写。

但是，读写穿透模式是**同步更新Cache和DB**，而异步缓存写入模式**只是更新Cache，不直接更新DB，通过异步批量的方式来更新DB。**

# 二、Redis数据结构

## 2.1 Redis常用的数据结构有哪些？

- **5种基本数据结构：**String（字符串）、List（列表）、Hash（散列）、Set（集合）、Zset（有序集合）。
- **3种特殊数据结构：**HyperLogLogs（基数统计）、Bitmap（位存储）、Geospatial（地理位置）。

## 2.2 String的应用场景有哪些？

String是一种二进制安全的数据结构，可以用来存储任何类型的数据，比如字符串、整数、浮点数、图片（图片的base64编码或解码或图片的路径）、序列化后的对象。

- **常规数据的缓存**，比如session、token、序列化后的对象、图片的编码或路径等。
- **计数**，比如用户单位时间的请求数、页面单位时间的访问数等。
- **分布式锁**。

## 2.3 存储对象数据使用String还是Hash更好？

- String存储的是序列化后的对象数据、存储的是整个对象。Hash是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或添加部分字段。如果对象中的某些字段需要经常变动或需要单独查询对象中某些字段信息，就更适合用Hash。
- String存储相对来说更节省内存，缓存相同数量的对象数据，String消耗的内存约是Hash的一半。并且存储具有多层嵌套的对象时也方便很多。

总结：绝大多数情况下，更建议使用String来存储对象数据。

## 2.4 String的底层实现是什么？

Redis虽然是基于C语言编写的，但是Redis中的String类型的底层并不是C语言中的字符串，而是作者自己编写了SDS（简单动态字符串）作为底层实现的。

SDS相比于C语言的字符串有以下提升：

1. **可以避免缓冲区溢出：**C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。
2. **获取字符串长度的复杂度较低：** C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。
3. **减少内存分配次数：**为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。
4. **二进制安全：**C 语言中的字符串以空字符 `\0` 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。

## 2.5 购物车信息是用String还是Hash存储更好？

上面2.3中分析过了，由于购物车中的商品频繁需要修改和变动，所以购物车信息建议使用Hash存储：

- 用户ID为Key
- 商品ID为field，商品数量为Value

![Hash维护简单的购物车信息](https://oss.javaguide.cn/github/javaguide/database/redis/hash-shopping-cart.png)

### 2.5.1 用户购物车信息的维护具体应该怎么操作？

1. 用户添加商品就是往Hash里面添加field和value；
2. 查询购物车信息就是遍历Hash；
3. 更改商品数量就修改对应的value值；
4. 删除商品就是删除Hash中对应的field；
5. 清空购物车就直接删除对应Key；

## 2.6 用Redis实现一个排行榜怎么做？

可以用到Redis中的Zset数据结构，可以实现各种排行榜，比如送礼物排行榜、微信步数排行榜、段位排行榜等等。

其中一些常见的Redis命令：`ZRANGE`（从小到大排序）、`ZREVRANGE`（从大到小排序）、`ZREVRANK`（指定元素排序）。

## 2.7 Set的应用场景是什么？

Redis 中 `Set` 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 `HashSet` 。

- **存放数据不能重复的场景。**比如文章点赞、动态点赞等等。
- **需要获取多个数据源交集、并集和差集的场景。**比如共同好友、共同粉丝、共同关注、好友推荐等等。
- **需要随机获取数据源中的元素。**比如抽奖系统、随机点名等等。

## 2.8 如何用Set实现抽奖系统？

- `SADD key member1 member2 ...`：向指定集合添加一个或多个元素。
- `SPOP key count`：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的情况。
- `SRANDMEMBER key count`：随机获取指定集合中指定数量的元素，适合运行重复中奖的情况。

## 2.9 如何用Bitmap统计活跃用户？

Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。

可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。

如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。

初始化数据：

```sh
SETBIT 20210308 1 1
(integer) 0
SETBIT 20210308 2 1
(integer) 0
SETBIT 20210309 1 1
(integer) 0
```

统计 20210308~20210309 总活跃用户数:

```sh
BITOP and desk1 20210308 20210309
(integer) 1
BITCOUNT desk1
(integer) 1
```

统计 20210308~20210309 在线活跃用户数:

```sh
BITOP or desk2 20210308 20210309
(integer) 1
BITCOUNT desk2
(integer) 2
```

# 三、Redis持久化机制

## 3.1 说一说Redis支持的持久化机制？

- 快照（RDB）
- 只追加文件（AOF）
- RDB和AOF的混合持久化（Redis 4.0新增）

## 3.2 RDB持久化

### 3.2.1 什么是RDB持久化？

Redis 可以通过创建快照来获得存储在内存里面的数据在 **某个时间点** 上的副本。

Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。

快照持久化是 Redis **默认**采用的持久化方式，在 `redis.conf` 配置文件中默认有此下配置：

```clojure
save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。

save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。
```

### 3.2.2 RDB创建快照时会阻塞主线程吗？

Redis提供了两个命令来生成RDB快照文件：

- `save`：同步保存操作，会阻塞Redis主线程；
- `bgsave`：fork出一个子进程，子进程执行，不会阻塞Redis主线程，默认选项。

## 3.3 AOF持久化

### 3.3.1 什么是AOF持久化？

与RDB持久化相比，AOF持久化的实时性更好。

默认情况下Redis没有开启AOF，但是**Redis 6.0之后默认是开启的**。

开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 `server.aof_buf` 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ `fsync`策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。

### 3.3.2 AOF的基本流程？

1. **命令追加：**所有的写命令会追加到AOF缓冲区中。
2. **文件写入：**将AOF缓冲区的数据写入到AOF文件中。这一步需要调用`writer`函数，将数据写入到系统内核缓冲区后直接返回。（此时并没有同步到磁盘）
3. **文件同步：**AOF缓冲区根据对应的持久化方式向磁盘做同步操作。
4. **文件重写：**随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。
5. **重启加载：**当Redis重启时，可以加载AOF文件进行数据恢复。

![AOF 工作基本流程](https://oss.javaguide.cn/github/javaguide/database/redis/aof-work-process.png)

### 3.3.3 持久化方式有哪些？

Redis配置文件中有三种不同的AOF持久化方式：

1. `appendfsync always`：主线程调用 `write` 执行写操作后，后台线程（ `aof_fsync` 线程）立即会调用 `fsync` 函数同步 AOF 文件（刷盘），`fsync` 完成后线程返回，这样会严重降低 Redis 的性能（`write` + `fsync`）。
2. `appendfsync everysec` ：主线程调用 `write` 执行写操作后立即返回，由后台线程（ `aof_fsync` 线程）每秒钟调用 `fsync` 函数（系统调用）同步一次 AOF 文件（`write`+`fsync`，`fsync`间隔为 1 秒）
3. `appendfsync no` ：主线程调用 `write` 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（`write`但不`fsync`，`fsync` 的时机由操作系统决定）。

可以看出：**这 3 种持久化方式的主要区别在于 `fsync` 同步 AOF 文件的时机（刷盘）**。

### 3.3.4 AOF为什么是在执行完命令后记录日志？

关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。

![AOF 记录日志过程](https://oss.javaguide.cn/github/javaguide/database/redis/redis-aof-write-log-disc.png)

- 避免额外的检查开销，AOF记录日志不会对命令进行语法检查；
- 在命令执行完之后再记录，不会阻塞当前命令执行。

**缺点：**

- 如果刚执行完命令Redis就宕机，会导致对应的修改丢失；
- 可能会阻塞后续其他命令的执行，因为AOF记录日志是在Redis主线程中进行的。

### 3.3.5 AOF文件重写了解吗？

当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。

![AOF 重写](https://oss.javaguide.cn/github/javaguide/database/redis/aof-rewrite.png)

由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。

AOF 文件重写期间，Redis 还会维护一个 **AOF 重写缓冲区**，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容**追加**到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。

## 3.4 Redis 4.0对持久化机制做了什么优化？

由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。

这样做的好处是可以结合 RDB 和 AOF 的优点, **快速加载**同时**避免丢失过多的数据**。

当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，**可读性较差。**

## 3.5 如何选择RDB和AOF？

### 3.5.1 RDB的优势

- RDB文件存储的内容是经过压缩的二进制数据，保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。
- 使用RDB文件恢复数据，直接解析还原数据即可，不需要一条条地执行命令，速度非常快。

### 3.5.2 AOF的优势

- AOF的数据安全性更高，可以实时或秒级持久化数据。RDB会对机器的CPU资源和内存资源产生严重的影响。
- RDB可能会存在版本不兼容的问题。
- AOF以一种易于理解和解析的格式包含所有操作的日志。方便导出AOF文件进行分析。

**总结：**

- Redis保存的数据丢失一些也没有影响的话，可以使用RDB；
- 不建议单独使用AOF，因为时不时创建一个RDB快照可以进行数据库备份、更快的重启以及解决AOF引擎错误。
- 如果保存的数据要求安全性比较高的话，建议同时开启RDB和AOF持久化或者开启混合持久化。

# 四、Redis线程模型

## 4.1 Redis单线程模型了解吗？

**Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型**，这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。

### 4.1.1 既然是单线程，那怎么监听大量的客户端连接呢？













