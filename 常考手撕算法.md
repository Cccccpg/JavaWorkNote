# 一、排序算法

## 1.1 冒泡排序

### 1.1.1 算法思想

重复遍历要排序的序列，依次比较两个元素，如果顺序错误，就交换位置。

![冒泡排序](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/bubble_sort.gif)

### 1.1.2 算法步骤

1. 比较相邻元素。如果第一个比第二个大，就换位置；
2. 对每一对相邻元素做同样的工作，从开始第一队到结尾的最后一对，这样每次都能找出最大的一个；
3. 针对所有元素重复以上步骤；
4. 重复1-3步，直到排序完成。

### 1.1.3 代码实现

```java
/**
 * 冒泡排序，从小到大
 * nums = [1,8,6,7,9,2];
 * @param nums
 */
public static int[] bubbleSort(int[] nums){
    for(int i = nums.length - 1; i > 0; i--){
        for (int j = 0; j < i; j++) {
            if (nums[j] > nums[j + 1]){
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
    return nums;
}
```

### 1.1.4 算法分析

- **稳定性**：稳定
- **时间复杂度**：最佳：O(n) ，最差：O(n2)， 平均：O(n2)
- **空间复杂度**：O(1)
- **排序方式**：占用常数内存，不占用额外内存

## 1.2 选择排序

### 1.2.1 算法思想

在未排序的序列中找到最小的元素，然后存放在最开始的位置，然后继续从未排序的元素中找最小的，以此类推。

特点就是不论什么顺序的数据，时间复杂度都是O(n^2)。

![Selection Sort](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/selection_sort.gif)

### 1.2.2 算法步骤

1. 首先在未排序的序列中找最小的元素，放到序列最开始的位置；
2. 然后在剩下的未排序序列中找最小的元素，放到已排序的序列末尾；
3. 重复第二步，直到排序结束。

### 1.2.3 代码实现

```java
/**
 * 选择排序，从小到大
 * @param nums
 * @return
 */
public static int[] selectionSort(int[] nums){
    for (int i = 0; i < nums.length; i++) {
        int min = Integer.MAX_VALUE, index = 0;
        for (int j = i; j < nums.length; j++){
            if (nums[j] < min){
                min = nums[j];
                index = j;
            }
        }
        int temp = nums[index];
        nums[index] = nums[i];
        nums[i] = temp;
    }
    return nums;
}
```

### 1.2.4 算法分析

- **稳定性**：不稳定
- **时间复杂度**：最佳：O(n2) ，最差：O(n2)， 平均：O(n2)
- **空间复杂度**：O(1)
- **排序方式**：不需要额外空间

## 1.3 快速排序

### 1.3.1 算法思想

用到了分治思想，将问题划分为子问题，然后排序子串，最后合并。

通过一趟排序将待排序列分为独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整体有序。

![RandomQuickSort](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/random_quick_sort.gif)

### 1.3.2 算法步骤

1. 从序列中随机挑选一个元素，作为基准(pivot)；
2. 重新排序，将所有比基准值小的元素摆放在基准前面，比基准值大的元素摆放在基准的后面。基准就位于中间位置，这就是分区（partition）。
3. 递归地把小于基准元素的子序列和大于基准元素的子序列进行快排。

### 1.3.3 代码实现

```java
//快排，递归
private static void quickSort(int[] nums, int low, int high) {
    if (low < high){
        int position = partition(nums, low, high);
        quickSort(nums, low, position - 1);
        quickSort(nums, position + 1, high);
    }
}

// 分区，返回每次分区的基值
private static int partition(int[] nums, int low, int high) {
    int pivot = nums[high];
    int index = low;
    for (int i = low; i < high; i++) {
        if (nums[i] <= pivot){
            swap(nums[i], nums[index]);
            index++;
        }
    }
    swap(nums[index], nums[high]);
    return index;
}

public static void swap(int num1, int num2){
    int temp = num1;
    num1 = num2;
    num2 = temp;
}
```

### 1.3.4 算法分析

- **稳定性**：不稳定
- **时间复杂度**：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn)
- **空间复杂度**：O(nlogn)

## 1.4 堆排序

### 1.4.1 算法思想

利用堆的数据结构特性，即子节点的值总是小于（或大于）其父节点。

![HeapSort](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/heap_sort.gif)

### 1.4.2 算法步骤

1. 将初始待排序列构建成大顶堆，次堆为初始的无序区。
2. 将堆顶元素 `R[1]` 与最后一个元素 `R[n]` 交换，此时得到新的无序区 `(R1, R2, ……, Rn-1)` 和新的有序区 (Rn), 且满足 `R[1, 2, ……, n-1]<=R[n]`；
3. 由于交换后的新堆R[1]可能违反堆的性质，因此需要对当前无序区重新调整，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区和有序区。不断重复，直到排序过程完成。

### 1.4.3 代码实现

```java
// 全局变量，用来记录当前堆的长度
public static int heapLen;

/**
* 堆排序
* @param nums
* @return
*/
public static int[] heapSort(int[] nums) {
    heapLen = nums.length;
    buildMaxHeap(nums);
    for (int i = nums.length - 1; i > 0; i--) {
        swap(nums, 0, i);
        heapLen--;
        heapify(nums, 0);
    }
    return nums;
}

/**
* 建立大顶堆
* @param nums
*/
private static void buildMaxHeap(int[] nums) {
    for (int i = nums.length / 2 - 1; i >= 0; i--) {
        heapify(nums, i);
    }
}

/**
* 调整大顶堆
* @param nums
* @param i
*/
private static void heapify(int[] nums, int i) {
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    int largest = i;
    if (left < heapLen && nums[left] > nums[largest]){
        largest = left;
    }
    if (right < heapLen && nums[right] > nums[largest]){
        largest = right;
    }
    if (largest != i){
        swap(nums, i, largest);
        heapify(nums, largest);
    }
}

private static void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

### 1.4.4 算法分析

- **稳定性**：不稳定
- **时间复杂度**：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)
- **空间复杂度**：O(1)

## 1.5 归并排序

### 1.5.1 算法思想

也是采用分治算法的典型，将已有序的子序列合并，得到完全有序的序列，也称为2路归并。代价是需要额外的内存空间。

![MergeSort](https://oss.javaguide.cn/github/javaguide/cs-basics/sorting-algorithms/merge_sort.gif)

### 1.5.2 算法步骤

1. 如果输入只有一个元素，则直接返回，否则将长度为n的输入序列分为两个长度为n/2的子序列；
2. 分别对这两个子序列进行归并排序，使子序列变为有序状态；
3. 设定两个指针，分别指向两个已经排序子序列的起始位置；
4. 比较两个指针所指向的元素，选择相对较小的放入到合并空间，并移动指针；
5. 重复第3步和第4步，直到全部有序

### 1.5.3 代码实现

```java
/**
 * 归并排序
 * @param nums
 * @return
*/
private static int[] mergeSort(int[] nums) {
    if (nums.length <= 1){
        return nums;
    }
    int middle = nums.length / 2;
    int[] numsLeft = Arrays.copyOfRange(nums, 0, middle);
    int[] numsRight = Arrays.copyOfRange(nums, middle, nums.length);
    return merge(mergeSort(numsLeft), mergeSort(numsRight));
}

private static int[] merge(int[] numsLeft, int[] numsRight) {
    int[] ansArr = new int[numsLeft.length + numsRight.length];
    int left = 0, right = 0, index = 0;
    // 对比
    while (left < numsLeft.length && right < numsRight.length){
        if (numsLeft[left] < numsRight[right]){
            ansArr[index] = numsLeft[left];
            left++;
        }else{
            ansArr[index] = numsRight[right];
            right++;
        }
        index++;
    }
    // 左边子序列的长度比右边子序列的长度更长
    if (left < numsLeft.length){
        while (left < numsLeft.length){
            ansArr[index] = numsLeft[left];
            left++;
            index++;
        }
    }else {
        while (right < numsRight.length){
            ansArr[index] = numsRight[right];
            right++;
            index++;
        }
    }
    return ansArr;
}
```

### 1.5.4 算法分析

- **稳定性**：稳定
- **时间复杂度**：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)
- **空间复杂度**：O(n)

















