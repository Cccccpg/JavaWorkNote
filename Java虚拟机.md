# 1、Java内存区域

如果没有特殊说明，都是针对的是 HotSpot 虚拟机。

## 1.1 运行时数据区

Java 虚拟机在执行 Java 程序时，会将内存划分为若干区域，划分的方式， 在 JDK1.8 和之前的方式略有不同。

JDK1.8 之前：（线程共享：堆、方法区、直接内存; 线程私有：虚拟机栈、本地方法栈、程序计数器）

![image-20230411094548816](pictures\image-20230411094548816.png)

JDK1.8：（线程共享：堆、方法区变为了元空间（放在了直接内存中）、直接内存; 线程私有：虚拟机栈、本地方法栈、程序计数器）

### 1.1.1 程序计数器

程序计数器可以看作是线程所执行的字节码的行号指示器，记录线程运行到哪一行的位置。

它主要有两个作用：

（1）字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

（2）在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候，能够知道该线程上次运行到哪儿了。

**⚠️注意**：程序计数器是**唯一**一个不会出现 `OutOfMemoryError `的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### 1.1.2 虚拟机栈

平常说的栈内存就是 Java 虚拟机栈，它由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。

![image-20230411095603092](pictures\image-20230411095603092.png)

**局部变量表**：主要存放编译期可知的各种数据类型、对象应用。

**操作数栈**：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算产生的临时变量也会放在操作数栈中。

**动态链接**：主要服务一个方法需要调用其他方法的场景。其作用就是为了**将符号引用转换为调用方法的直接引用**，这个过程被称为动态链接。

![image-20230411100010132](pictures\image-20230411100010132.png)

Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， **栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束**。

会出 `StackOverFlowError `和 `OOM `这两 个错误。

### 1.1.3 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 

在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

### 1.1.4 堆

Java 虚拟机所管理的内存中最大的一块，堆是所有线程共享的一块内存区域，在虚拟机启动时创建。

**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。

Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。

**JDK 1.7及之前**，堆内存通常被分为三部分：

1. 新生代
2. 老年代
3. 永久代

下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。

![image-20230411101143214](pictures\image-20230411101143214.png)

**JDK 1.8及之后**，永久代已经被元空间取代，元空间使用的是本地内存。

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

### 1.1.5 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

**方法区常用的参数有哪些？**

```java
//JDK 1.8之前
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
//JDK 1.8
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```

### 1.1.6 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 错误出现。

## 1.2 方法区和永久代以及元空间是什么关系？

方法区 和 永久代 的关系很像 Java 中接口和类的关系，类实现了接口。这里类就可以看做是永久代和元空间，接口可以看做是方法区

也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。

![image-20230411101856169](pictures\image-20230411101856169.png)

## 1.3 为什么要将永久代替换为元空间？

1. 整个永久代有一个 JVM 本身设置的**固定大小上限，无法进行调整**，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小，而且元空间**可以动态调整大小**。
2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样**能加载的类就更多**了。

## 1.4 字符串常量池

### 1.4.1 设计思想

JVM为了提高性能，减少内存开销，在实例化字符串常量时，进行了一些优化：

1. 为字符串开辟了一个字符串常量池，类似于缓存区；
2. 创建字符串常量时，首先查询字符串常量池中是否存在该字符串；
3. 若存在该字符，返回引用实例，若不存在，实例化该字符串并放入池中；

### 1.4.2 字符串常量的位置

JDK  1.6及之前：有**永久代**，运行时常量池在永久代，运行时常量池中包含字符串常量池。

JDK 1.7：有**永久代**，此时字符串常量池已经被分离出来，放在堆中。

JDK 1.8：无**永久代**，运行时常量池在元空间中，而字符串常量池在堆中。

### 1.4.3 常见的三种字符串操作及原理分析

```java
String s = "xxx";
```

在创建对象s时，JVM会先去常量池中通过`equals(key)`方法，判断是否有相同的对象：

- 如果有，则直接返回该对象在常量池中的引用；

- 如果没有，则会在常量池中创建一个新对象，再返回引用。

**这种方式创建的字符串对象，只会在常量池中。s最终指向<u>常量池中的引用</u>。**

---

```java
String s = new String("xxx");
```

这种方式会保证**字符串常量池和堆中都有这个对象**，没有就创建，**最后返回<u>堆内存中的对象引用</u>**。

首先会检查**字符串常量池**中是否存在"xxx"：

- 不存在，先在**字符串常量池**中创建一个字符串对象"xxx"，再去**堆内存**中创建一个字符串对象"xxx"；
- 存在，直接去**堆内存**中创建一个字符串对象"xxx"；

**最后将堆内存中的引用返回。**

**注意：**如果"xxx"在字符串常量池中存在，那么就只会创建一个对象（在堆中创建），如果不存在，那么会创建两个对象（在堆中和字符串常量池中都创建）。

---

```java
String s1 = new String("xxx");
String s2 = s1.intern();
```

String中的`intern()`方法是一个native方法，当调用这个方法时会进行判断：

- 如果常量池中已经包含一个等于此String对象的字符串（用`equals()`方法确定），则返回常量池中的字符串，此时指向常量池中的引用；
- 否则，将intern返回的引用指向当前字符串s1（JDK 1.6版本需要将s1复制到字符串常量池中）。此时指向堆中的引用。

### 1.4.4 经典面试题

（1）下面代码创建了几个对象，最终的结果是什么？

```java
String s1 = new String("he") + new String("llo");
String s2 = s1.intern();
System.out.println(s1 == s2);
```

在JDK 1.6环境下输出的是false，一共创建了6个对象，因为s1.intern()会将字符串复制到字符串常量池中，并创建新的对象，返回新对象的引用地址，所以结果为false。

在JDK 1.7及以上版本输出的是true，一共创建了5个对象。因为用了"+"，所以创建了`new SrtingBuilder()`对象，然后字符串常量池和堆中各创建了2个，所以一共是5个对象。之所以结果是true，是因为`s1.intern()`返回的是s1对象的引用地址，并没有创建新的对象，所以是true。

----

（2） 下面程序执行的结果是什么？

```java
String s0 = "ab";
String s1 = "ab";
String s2 = "a" + "b";
System.out.println(s0 == s1);//true
System.out.println(s0 == s2);//true
```

因为s0和s1中"ab"都是字符串常量，它们在编译期就已经被确定了，所以返回true；

而"a"和"b"也都是字符串常量，当一个字符串由多个字符串常量拼接而成时，那么它自己肯定也是字符串常量，所以s2在编译期也被优化为"ab"。

所以s0 == s1 == s2.

---

（3）字符串常量和字符串对象的比较

```java
String s0 = "ab";
String s1 = new String("ab");
String s2 = "a" + new String("b");
System.out.println(s0 == s1);//false
System.out.println(s0 == s2);//false
System.out.println(s1 == s2);//false
```

因为`new String()`创建的字符串并不是常量，不能再编译期就确定，所以所创建的字符串返回的是堆中的引用。

s0是字符串常量池中的引用，s1是堆中的引用，所以s0 == s1输出的当然是false；

同理s2的后半部分时新创建对象在堆中的引用，所以s0 == s2输出的当然是false；

`s1` 会在堆上创建一个新的 `String` 对象，而 `s2` 则会在常量池中创建一个新的 `String` 对象。虽然它们的值都是 `"ab"`，但是它们的引用不同，因此 `s1 == s2` 的比较结果是 `false`。

---

（4）String字符串不可变

```java
String s1 = "a" + "b" + "c";	//看jdk版本，5个或者1个
String a = "a";
String b = "b";
String c = "c";
String s2 = a + b + c;			//会创建两个StringBuilder对象和一个String对象，共三个对象
System.out.println(s1 == s2);//false
```

s1等价于`String s1 = "abc"`，而s2在JVM底层其实是通过`StringBuilder`中`append()`方法实现的。

所以在用"+"来拼接引用类型时，会产生新的String对象。

---

（5）下面的代码创建了几个对象？

```java
String s1 = "a" + "b" + "c";
```

在JDK 1.6及之前创建了五个对象，分别是 “a”,“b”,“c”,“ab”,"abc"。因为该版本中字符串常量池在永久代中，永久代的垃圾回收机制是很特殊的，在此区域内的数据是不会被回收的，只有到达临界值会发生Full GC，关闭JVM才会释放内存。

在JDK 1.7及之后创建了一个对象，也即JVM会在编译期进行优化。

### 1.4.5 总结

当字符串用"+"来拼接时，拼接后的字符串是否会生成新的对象，要根据"+"两侧的字符串判断。

- 如果两侧字符串均为字符串常量，即有确切的常量值，则JVM会在编译期对其进行优化，会将两个字符串常量拼接为一个字符串常量，如果拼接后的字符串常量在字符串常量池中存在的，则不创建对象，如果不存在，则会创建对象。
- 如果两侧字符串有字符串引用存在，因为引用的值在JVM的编译期是无法确定的，所以"+"无法被JVM编译器进行优化，只有在程序运行期来动态分配，并为凭借后的字符串创建新的对象（分配新的内存地址）。

## 1.5 说一说Java对象创建的过程？

![image-20230411104743775](pictures\image-20230411104743775.png)

1. 虚拟机遇到一条new指令时，首先会进行类加载检查：
   1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用；
   2. 检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那么需要先执行相应的类加载过程。
2. 对象所需要的内存大小在类加载之后就可以完全确定，分配内存就相当于把一块确定大小的内存从堆中划出来，具体的分配方式**取决于堆内存是否规整**，是否规整又取决于所采用的GC收集器是否带有压缩整理功能。
   1. 内存分配的两种方式：
      - 指针碰撞
      - 空闲列表![image-20230411153254246](pictures\image-20230411153254246.png)
   2. 内存分配并发问题（**保证线程安全**）
      - CAS+失败重试：**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
      - TLAB：为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
3. 内存分配完成后，虚拟机需要将分配到的内存空间都**初始化为零值**（不包括对象头），如果使用TLAB，这一步工作过程也可以提前至TLAB分配时进行。初始化的操作保证了对象实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
4. 初始化零值之后，虚拟机要对对象进行必要的设置，这些设置信息放在对象头中，对象头中包括：MarkWord、数组长度、类型指针。
5. 为对象的属性赋值，执行对象的构造方法。

## 1.6 说一说对象的内存布局？

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。

![image-20230411155351057](pictures\image-20230411155351057.png)

**Hotspot 虚拟机的对象头包括两部分信息**，**第一部分MarkWord，用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。（**只有数组对象才有第三部分，即数组长度部分**）

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

## 1.7 说一说对象的访问定位的方式？

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**和**直接指针**。

**使用句柄**：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

![image-20230411160355941](pictures\image-20230411160355941.png)

**直接指针**：如果使用直接指针访问，reference 中存储的直接就是对象的地址。

![image-20230411160443948](pictures\image-20230411160443948.png)

使用句柄来访问的最大好处是 reference 中存储的是**稳定**的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。

使用直接指针访问方式最大的好处就是**速度快**，它节省了一次指针定位的时间开销。

HotSpot 虚拟机主要使用的就是**直接指针**的方式来进行对象访问。

# 2、类加载过程和类加载器

## 2.1 类的生命周期

![image-20230411162522912](pictures\image-20230411162522912.png)

## 2.2 类加载过程

系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。







