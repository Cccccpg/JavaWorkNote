# 1、基础篇
## 1.1 TCP/IP网络模型有哪几层？
### 应用层
最上层的，也是我们能直接接触到的就是**应用层**（_Application Layer_），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。
所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。
应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。
而且应用层是**工作在操作系统中的用户态**，传输层及以下则**工作在内核态**。
### 传输层
应用层的数据包会传给传输层，**传输层**（_Transport Layer_）是为应用层提供网络支持的。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679901299528-c4f7f90e-fcbf-4137-afea-00247e324290.png#averageHue=%23fdf5ee&clientId=u687486a6-cbb7-4&from=paste&height=275&id=uf99e3836&name=image.png&originHeight=302&originWidth=616&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=24477&status=done&style=none&taskId=u0ff6c851-82fd-46f4-b631-590eae10a19&title=&width=559.9999878623271)
**在传输层会有两个传输协议，分别是 TCP 和 UDP。**

1. **传输控制协议 TCP**（Transmisson Control Protocol）--提供 **面向连接** 的，**可靠的** 数据传输服务。有很多特性流量控制、超时重传、拥塞控制等
2. **用户数据协议 UDP**（User Datagram Protocol）--提供 **无连接** 的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。

应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 **TCP 段**（_TCP Segment_）。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679901552194-685add18-0e74-4faf-b527-5da90da82f9f.png#averageHue=%23c9e38b&clientId=u687486a6-cbb7-4&from=paste&height=368&id=uceba1649&name=image.png&originHeight=405&originWidth=614&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=26750&status=done&style=none&taskId=u5b733357-3ff4-4028-806a-26467152f98&title=&width=558.1818060835534)
当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**。
比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。
由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。
### 网络层
传输层可能大家刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。
实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。
也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是**网络层**（_Internet Layer_）。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679902017703-d2e3100e-6237-4b15-ae95-fcc3f23457ae.png#averageHue=%23fcf2ec&clientId=u687486a6-cbb7-4&from=paste&height=440&id=u09e79643&name=image.png&originHeight=484&originWidth=627&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=42177&status=done&style=none&taskId=u21600766-8a0a-447b-b1d4-2bbc8a3232e&title=&width=569.999987645583)
网络层最常使用的是 IP 协议（_Internet Protocol_），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 IP 报文。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679902324564-f1b263c0-d1b3-4bec-b72b-1e7b13807d56.png#averageHue=%23f9f7f4&clientId=u687486a6-cbb7-4&from=paste&height=428&id=u70a38d6f&name=image.png&originHeight=471&originWidth=775&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=126323&status=done&style=none&taskId=u63366356-2500-4a31-bb32-5c04f3e822c&title=&width=704.5454392748434)
网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。
我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学
因此，需要将 IP 地址分成两种意义：

- 一个是**网络号**，负责标识该 IP 地址是属于哪个「子网」的；
- 一个是**主机号**，负责标识同一「子网」下的不同主机；

怎么分的呢？这需要配合**子网掩码**才能算出 IP 地址 的网络号和主机号。
举个例子，比如 10.100.122.0/24，后面的/24表示就是 255.255.255.0 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。
知道了子网掩码，该怎么计算出网络地址和主机地址呢？
将 10.100.122.2 和 255.255.255.0 进行**按位与运算**，就可以得到网络号，如下图：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679902753943-7d949958-e910-4e55-9afc-2b8c2ee88913.png#averageHue=%23e2e5a6&clientId=u687486a6-cbb7-4&from=paste&height=443&id=u6e500567&name=image.png&originHeight=487&originWidth=543&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=156290&status=done&style=none&taskId=ue05e1634-404d-4f5f-8a8a-9166e448dd2&title=&width=493.6363529370838)
将 255.255.255.0 取反后与IP地址进行进行**按位与运算**，就可以得到主机号。
上述例子求得主机号为`0.0.0.2`
在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。
除了寻址能力， IP 协议还有另一个重要的能力就是**路由**。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。
路由器寻址工作中，就是要找到目标地址的子网，找到后再把数据包转发给对应的网络内。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679903096518-cdc65bae-cb60-4c98-899d-a5ec0372ae44.png#averageHue=%23f6f4f1&clientId=u687486a6-cbb7-4&from=paste&height=513&id=u973ace62&name=image.png&originHeight=564&originWidth=717&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=141907&status=done&style=none&taskId=u19d8b6ff-4675-4a07-99e6-785b2a6005f&title=&width=651.8181676904035)
所以，**IP 协议的寻址作用就像是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘**。
### 网络接口层
生成了 IP 头部之后，接下来要交给**网络接口层**（_Link Layer_）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679903273213-0d6a1238-ba90-41b9-993a-7d0b1753b06d.png#averageHue=%23fbf3ee&clientId=u687486a6-cbb7-4&from=paste&height=603&id=u9b4c4740&name=image.png&originHeight=663&originWidth=645&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=64070&status=done&style=none&taskId=uf7f14e61-efb3-4a2e-8369-cdf43d71280&title=&width=586.363623654547)
IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。
什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。
以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。
MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。
所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来**标识**网络上的设备。
### 总结
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679903501941-04aa4270-005a-4ce7-8f6c-9433803ae91c.png#averageHue=%23faf4ef&clientId=u687486a6-cbb7-4&from=paste&height=717&id=u1762637f&name=image.png&originHeight=789&originWidth=651&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=86518&status=done&style=none&taskId=u92d776dc-0f99-429f-81d2-0f9a1a5f1f4&title=&width=591.8181689908685)
每一层数据的封装格式：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679903540671-b039e497-4748-4029-886c-769c7ef48b9b.png#averageHue=%23eaddc0&clientId=u687486a6-cbb7-4&from=paste&height=393&id=u8e5e223a&name=image.png&originHeight=432&originWidth=769&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=70888&status=done&style=none&taskId=ue35eb143-fc9b-4c5f-adfc-234421a4e51&title=&width=699.0908939385221)
网络接口层的传输单位是帧（frame），
IP 层的传输单位是包（packet），
TCP 层的传输单位是段（segment），
HTTP 的传输单位则是消息或报文（message）。
但这些名词并没有什么本质的区分，可以统称为数据包。
## 1.2 输入网址到网页显示过程中，发生了什么？
### 1.2.1 HTTP
:::info
浏览器第一步：解析URL，生成HTTP请求信息
:::
首先浏览器做的第一步工作就是要对 URL 进行解析，从而生成发送给 Web 服务器的请求信息。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679903874578-f93b1e16-19b5-4a67-9037-35a774710457.png#averageHue=%23f8f6f2&clientId=u687486a6-cbb7-4&from=paste&id=u997b7e22&name=image.png&originHeight=1879&originWidth=1503&originalType=url&ratio=1.100000023841858&rotation=0&showTitle=false&size=685813&status=done&style=none&taskId=u84259787-a8b8-4ff1-b49a-0cc4d9af2a4&title=)
所以图中URL地址其实就是向服务器请求文件资源。
**Q：要是上图中蓝色块中URL元素都省略了，那请求的是哪个文件？**
**A：**当没有路径名时，就代表访问根目录下事先设置的**默认文件**，也即`/index.html`或者`/default/html`这类默认文件。
根据对URL解析的结果，生成HTTP请求信息。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679904395254-8d6d64da-4b91-492e-916e-6ddf371d4efc.png#averageHue=%23f8f4ed&clientId=u687486a6-cbb7-4&from=paste&id=u780449c5&name=image.png&originHeight=1847&originWidth=1773&originalType=url&ratio=1.100000023841858&rotation=0&showTitle=false&size=794727&status=done&style=none&taskId=uc002267b-654d-4cfd-80cf-cbb8c987a01&title=)
### 1.2.2 DNS——真实地址查询
通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。
但在发送之前，还有一项工作需要完成，那就是**查询服务器域名对应的 IP 地址**，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。

---

比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。

---

有一种服务器就专门保存了 `Web` 服务器域名与 `IP` 的对应关系，它就是 `DNS `服务器。
DNS 中的域名都是用**句点**来分隔的，比如 `www.server.com`，这里的句点代表了不同层次之间的**界限**。
在域名中，**越靠右**的位置表示其层级**越高**。
域名的层级关系类似一个树状结构：

- 根 DNS 服务器（.）
- 顶级域 DNS 服务器（.com）
- 权威 DNS 服务器（server.com）

![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679905300365-ae5c815f-7cd9-4a3b-9ae4-6782f5773f86.png#averageHue=%23fbfbfb&clientId=u687486a6-cbb7-4&from=paste&id=u93b07153&name=image.png&originHeight=420&originWidth=621&originalType=url&ratio=1.100000023841858&rotation=0&showTitle=false&size=72888&status=done&style=none&taskId=u52a1c982-69dd-4757-8fed-0a988510c80&title=)

---

**域名解析的工作流程**

1. 客户端首先发出一个DNS请求，问`www.server.com`的IP是啥，并发给本地的DNS服务器（也就是本地客户端的TCP/IP设置中填写的DNS服务器地址）。
2. 本地域名服务器收到客户端请求后，如果缓存的表格中能找到这个网址的IP地址，那么就直接返回IP地址；如果没有，则本地DNS会去问它的根域名服务器，这个网址的IP地址。根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3. 根DNS收到本地DNS请求后，发现网址后置是`.com`，则会告诉本地DNS这个网址归`.com`顶级域名服务器管理，并把这个顶级域名服务器的地址给本地DNS。
4. 本地DNS收到地址后，去询问顶级域名服务器，然后顶级域名服务器会给`www.server.com`区域的权威DNS服务器地址。
5. 本地DNS服务器去询问权威DNS服务器，权威DNS服务器查询到IP地址后，告诉本地DNS。
6. 本地DNS再将IP地址告诉客户端，客户端与目标建立连接。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679906088589-13a3ff6a-3f70-4d58-8c5b-5475e9c7eb68.png#averageHue=%23faf8f5&clientId=u687486a6-cbb7-4&from=paste&id=u12cfe1c1&name=image.png&originHeight=1095&originWidth=1505&originalType=url&ratio=1.100000023841858&rotation=0&showTitle=false&size=708614&status=done&style=none&taskId=u63393b04-efb6-4321-a1bc-dd203433432&title=)
总结：DNS域名解析的过程类似于问路，**只指路不带路。**
**Q：是不是每次域名解析都要经过这么多步骤？**
**A：**不是。浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回；如果没有，就去问操作系统，操作系统也会查看自己缓存，如果有，就直接返回；如果没有，再去hosts文件看。以上步骤都没有，才会去询问本地DNS服务器。
### 1.2.3 协议栈
通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**。
协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679906466711-82eb824f-edf3-4b54-a12e-31a1beb75754.png#averageHue=%23f2f2f0&clientId=u33e825a6-4c8f-4&from=paste&id=u190529d6&name=image.png&originHeight=917&originWidth=903&originalType=url&ratio=1.100000023841858&rotation=0&showTitle=false&size=358306&status=done&style=none&taskId=ubdfcc9a4-578c-41a6-b14c-a668cbcd966&title=)
应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。
协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。
协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。
此外 IP 中还包括 `ICMP `协议和 `ARP `协议。

- ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。
- ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。
### 1.2.4 TCP——可靠传输
HTTP 是基于 TCP 协议传输的，所以在这我们先了解下 TCP 协议。
TCP报文头格式
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679906992088-762084c8-acb6-41c7-a948-13817d2944e6.png#averageHue=%23fdf0c9&clientId=u33e825a6-4c8f-4&from=paste&id=ubc8f87d3&name=image.png&originHeight=749&originWidth=978&originalType=url&ratio=1.100000023841858&rotation=0&showTitle=false&size=268183&status=done&style=none&taskId=uc52bba36-4aef-497b-bfbc-2f63aeaf070&title=)
首先，**源端口号**和**目标端口**号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。
接下来有包的**序**号，这个是为了解决包乱序的问题。
还有应该有的是**确认号**，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。
接下来还有一些**状态位**。例如 `SYN `是发起一个连接，`ACK `是回复，`RST `是重新连接，`FIN `是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。
还有一个重要的就是**窗口大小**。TCP 要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。
除了做流量控制以外，TCP还会做**拥塞控制**，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。

---

在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为**三次握手**。
这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679907524357-5d7db6a9-c208-4e6f-8f5a-c99d24a57877.png#averageHue=%23f8ecca&clientId=u33e825a6-4c8f-4&from=paste&id=u3e307ee9&name=image.png&originHeight=1019&originWidth=1221&originalType=url&ratio=1.100000023841858&rotation=0&showTitle=false&size=563718&status=done&style=none&taskId=u21421014-2ddf-40c9-b6fc-552a668857d&title=)

- 一开始，客户端和服务端都处于 `CLOSED `状态。先是服务端主动监听某个端口，处于 `LISTEN `状态。
- 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。
- 服务端收到发起的连接，返回 `SYN`，并且 `ACK `客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。
- 客户端收到服务端发送的 `SYN `和 `ACK `之后，发送对 `SYN `确认的 `ACK`，之后处于 `ESTABLISHED `状态，因为它一发一收成功了。
- 服务端收到 `ACK `的 `ACK `之后，处于 `ESTABLISHED`状态，因为它也一发一收了。

所以三次握手目的是**保证双方都有发送和接收的能力**。

---

**TCP报文生成**
TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 80， HTTPS 默认端口号是 443）。
在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。
至此，网络包的报文如下图。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679908004319-76b899e5-5926-425f-a6b4-c3b073c27381.png#averageHue=%23e1cd92&clientId=u33e825a6-4c8f-4&from=paste&id=u4f4830cc&name=image.png&originHeight=1038&originWidth=1233&originalType=url&ratio=1.100000023841858&rotation=0&showTitle=false&size=613564&status=done&style=none&taskId=u98a3088d-f1c8-46fa-ae29-26f538fdace&title=)
### 1.2.5 IP——远程定位
TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679908110897-8cfac233-c273-4901-8848-51bf9c3969cf.png#averageHue=%23eee8ca&clientId=u33e825a6-4c8f-4&from=paste&id=ud8ea0705&name=image.png&originHeight=1806&originWidth=906&originalType=url&ratio=1.100000023841858&rotation=0&showTitle=false&size=360645&status=done&style=none&taskId=ub4338468-9be9-40bd-93e6-4fae79edb44&title=)
在 IP 协议里面需要有**源地址 IP** 和 **目标地址 IP**：

- 源地址IP，即是客户端输出的 IP 地址；
- 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的**协议号**，要填写为 06（十六进制），表示协议为 TCP。

---

**Q：当有多个网卡时，就会有多个IP地址，那么这个源地址IP应该选哪个？**
**A：**需要根据**路由表**规则，来判断哪一个网卡作为源地址 IP。就是计算网络号，看与哪一个网卡的Destination相匹配。
### 1.2.6 MAC——两点传输
生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/28551010/1679909000239-4e52e35c-9f26-4b3c-ba56-e1ac182a88c7.png#averageHue=%23d1e5cf&clientId=u33e825a6-4c8f-4&from=paste&id=uf55b043f&name=image.png&originHeight=558&originWidth=558&originalType=url&ratio=1.100000023841858&rotation=0&showTitle=false&size=92017&status=done&style=none&taskId=u31b0d8ec-bcf1-4a13-9e8c-c4142a6736c&title=)
在 MAC 包头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。
一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：

- 0800 ： IP 协议
- 0806 ： ARP 协议






# 2、HTTP篇






# 3、TCP篇







# 4、IP篇
