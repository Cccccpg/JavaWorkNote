# 一、回溯算法
## 1.1 回溯三部曲

- 递归函数的返回值以及参数
- 回溯函数的终止条件
- 单层搜索的过程

回溯算法的搜索过程其实就是一个树型结构的遍历过程，for循环用来横向遍历，递归的过程是纵向遍历。
```java
public void backtracking(参数) {
    if (终止条件) {
    	存放结果;
        return;
    }
    
    for (int i = startIndex; i <= n; i++) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 1.2 剪枝优化
可以剪枝的地方就在递归中每层的for循环所选择的起始位置。
如果for循环选择的起始位置之后的元素个数已经不足，那么就没有必要再进行搜索。
**未优化前：**for (int i = startIndex; i <= n; i++)
其中，i就是for循环中的起始位置
**优化后：**for(int i = startIndex; i <= n - (k - path.size() + 1); i++)
## 1.3 经典题目
### 1、复原IP地址
有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。
输入：s = "25525511135" 
输出：["255.255.11.135","255.255.111.35"]
```java
private List<String> res = new ArrayList<>();

public List<String> restoreIpAddresses(String s) {
    if (s.length() < 4 || s.length() > 12){
        return res;
    }
    backTracking(s, 0, 0);
    return res;
}

public void backTracking(String s, int startIndex, int pointNum){
    if (pointNum == 3){
        if (isValid(s, startIndex, s.length() - 1)){
            res.add(s);
        }
        return;
    }

    for (int i = startIndex; i < s.length(); i++){
        //判断[startIndex, i]区间内的子串是否合法,若合法，则加.
        if (isValid(s, startIndex, i)){
            //加给字符串加"."
            s = s.substring(0, i + 1) + '.' + s.substring(i + 1);
            pointNum++;
            backTracking(s, i + 2, pointNum);
            pointNum--;
            s = s.substring(0, i + 1) + s.substring(i + 2);
        }else {
            break;
        }
    }
}

public boolean isValid(String s, int start, int end){
    if (start > end) {
        return false;
    }
    if (s.charAt(start) == '0' && start != end) {
        return false;
    }
    int num = 0;
    for (int i = start; i <= end; i++){
        if (s.charAt(i) > '9' || s.charAt(i) < '0') {
            return false;
        }
        num = num * 10 + (s.charAt(i) - '0');
        if (num > 255){
            return false;
        }
    }
    return true;
}
```
### 2、全排列
给定一个 没有重复 数字的序列，返回其所有可能的全排列。
示例:

- 输入: [1,2,3]
- 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]
```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合
    LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果
    public List<List<Integer>> permute(int[] nums) {
        if (nums.length == 0){
            return result;
        }
        boolean[] used = new boolean[nums.length];
        permuteHelper(nums, used);
        return result;
    }

    private void permuteHelper(int[] nums, boolean[] used){
        if (path.size() == nums.length){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++){
            //树枝去重
            if (used[i]){
                continue;
            }
            used[i] = true;
            path.add(nums[i]);
            permuteHelper(nums, used);
            path.removeLast();
            used[i] = false;
        }
    }
}
```
总结：排列问题与组合问题不同点

- 每层都是从0开始搜索而不是startIndex
- 需要used数组记录path里都放了哪些元素了
### 3、N皇后问题
与之前的解法一样，将二维矩阵抽象成一个树。
矩阵的高就相当于树的高度，也就是回溯的层数；矩阵的宽就相当于每个节点的宽度。
```java
private List<List<String>> result = new ArrayList<>();
public List<List<String>> solveNQueens(int n){
    char[][] chessBoard = new char[n][n];
    for (char[] chars : chessBoard) {
        Arrays.fill(chars, '.');
    }
    backTracking(n, 0, chessBoard);
    return result;
}

public void backTracking(int n, int row, char[][] chessBoard){
    if (row == n){
        result.add(charArray2List(chessBoard));
        return;
    }
    for (int col = 0; col < n; col++){
        if (isValid(n, row, col, chessBoard)){
            chessBoard[row][col] = 'Q';
            backTracking(n, row + 1, chessBoard);
            chessBoard[row][col] = '.';
        }
    }
}

//将二维字符数组转换为list
public List<String> charArray2List(char[][] chessBoard) {
    List<String> list = new ArrayList<>();
    for (char[] chars : chessBoard) {
        list.add(String.valueOf(chars));
    }
    return list;
}

public boolean isValid(int n, int row, int col, char[][] chessBoard){
    //检查该列是否符合要求
    for (int i = 0; i < row; i++){
        if (chessBoard[i][col] == 'Q'){
            return false;
        }
    }
    //不用检查行，因为在单层搜索的过程中，每一层递归只会选一行的一个元素
    //所以不用检查每行是否符合要求
    //检查对角线是否符合要求
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){
        if (chessBoard[i][j] == 'Q'){
            return false;
        }
    }
    //检查反对角线是否符合要求
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){
        if (chessBoard[i][j] == 'Q'){
            return false;
        }
    }
    return true;
}
```
### 4、解数独
难点就是二维递归
```java
public void solveSudoku(char[][] board) {
    backTracking(board);
}

public boolean backTracking(char[][] board){
    for(int i = 0; i < board.length; i++){
        for(int j = 0; j < board[0].length; j++){
            if(board[i][j] != '.'){
                continue;
            }
            for(char k = '1'; k <= '9'; k++){
                if(isValid(i, j, k, board)){
                    board[i][j] = k;
                    if(backTracking(board)){
                        return true;
                    }
                    board[i][j] = '.';
                }
            }
            return false;
        }
    }
    return true;
}

public boolean isValid(int row, int col, char k, char[][] board){
    //判断同行是否重复
    for(int i = 0; i < 9; i++){
        if(board[row][i] == k){
            return false;
        }
    }
    //判断同列是否重复
    for(int i = 0; i < 9; i++){
        if(board[i][col] == k){
            return false;
        }
    }
    //判断九宫格内是否有重复
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for(int i = startRow; i < startRow + 3; i++){
        for(int j = startCol; j < startCol + 3; j++){
            if(board[i][j] == k){
                return false;
            }
        }
    }
    return true;
}
```
本题不用考虑终止条件，解数独的题目遍历整个树形结构寻找可能的叶子结点就直接返回，不用和平常那样，找到所有的可能。
而且递归的下一层的棋盘一定比上一层多一个数，等数都填满了，递归自然就终止了。
# 二、贪心算法

**贪心的本质就是选择每一阶段的局部最优，从而达到全局最优。**

比如：有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？

指定每次拿最大的，最终结果就是拿走最大数额的钱。

每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。

## 2.1 什么时候用贪心？

**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。

**刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心**。

## 2.2 解题步骤

1. 将问题分解成若干子问题
2. 找出适合的贪心策略
3. 求解每个子问题的最优解
4. 将局部最优解堆叠成全局最优解

# 三、动态规划

## 3.1 解题步骤

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 3.2 0-1背包问题

![image-20230406194254995](pictures\image-20230406194254995.png)

有n件物品和一个最多能背重量为 w 的背包。第 i 件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。这种问题是最经典的0-1背包问题。

假如背包最大容量为4，

|       | 重量 | 价值 |
| :---: | :--: | :--: |
| 物品0 |  1   |  15  |
| 物品1 |  3   |  20  |
| 物品2 |  4   |  30  |

用解题步骤：

1、确定dp数组以及下标的含义

使用二维数组，表示从下标为[0-i]的物品里随意取，放进价值为j的背包中的价值和最大。

2、确定递推公式

```java
1、不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)
2、放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值。
    
dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
```

3、dp数组如何初始化

```css
如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。

再看其他情况。

状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。

dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

那么很明显当 j < weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。

当j >= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。

其实从递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。
```

4、确定遍历顺序

5、举例验证

核心代码：

```java
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

## 3.3 完全背包问题

完全背包和01背包唯一不同的地方就是，每种物品有无限件。

我们知道01背包内嵌的循环是**从大到小遍历，为了保证每个物品仅被添加一次。**

而完全背包的物品是**可以添加多次的，所以要从小到大去遍历**，即：

```java
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

如果要求组合数，那外层for循环放物品，内层循环遍历背包。递推公式：

```java
dp[j] += dp[j - nums[i]];
```

如果要求排列数，那外层for循环放背包，内层遍历物品。







