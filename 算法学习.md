# 一、回溯算法
## 1.1 回溯三部曲

- 递归函数的返回值以及参数
- 回溯函数的终止条件
- 单层搜索的过程

回溯算法的搜索过程其实就是一个树型结构的遍历过程，for循环用来横向遍历，递归的过程是纵向遍历。
```java
public void backtracking(参数) {
    if (终止条件) {
    	存放结果;
        return;
    }
    
    for (int i = startIndex; i <= n; i++) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 1.2 剪枝优化
可以剪枝的地方就在递归中每层的for循环所选择的起始位置。
如果for循环选择的起始位置之后的元素个数已经不足，那么就没有必要再进行搜索。
**未优化前：**for (int i = startIndex; i <= n; i++)
其中，i就是for循环中的起始位置
**优化后：**for(int i = startIndex; i <= n - (k - path.size() + 1); i++)
## 1.3 经典题目
### 1、复原IP地址
有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。
输入：s = "25525511135" 
输出：["255.255.11.135","255.255.111.35"]
```java
private List<String> res = new ArrayList<>();

public List<String> restoreIpAddresses(String s) {
    if (s.length() < 4 || s.length() > 12){
        return res;
    }
    backTracking(s, 0, 0);
    return res;
}

public void backTracking(String s, int startIndex, int pointNum){
    if (pointNum == 3){
        if (isValid(s, startIndex, s.length() - 1)){
            res.add(s);
        }
        return;
    }

    for (int i = startIndex; i < s.length(); i++){
        //判断[startIndex, i]区间内的子串是否合法,若合法，则加.
        if (isValid(s, startIndex, i)){
            //加给字符串加"."
            s = s.substring(0, i + 1) + '.' + s.substring(i + 1);
            pointNum++;
            backTracking(s, i + 2, pointNum);
            pointNum--;
            s = s.substring(0, i + 1) + s.substring(i + 2);
        }else {
            break;
        }
    }
}

public boolean isValid(String s, int start, int end){
    if (start > end) {
        return false;
    }
    if (s.charAt(start) == '0' && start != end) {
        return false;
    }
    int num = 0;
    for (int i = start; i <= end; i++){
        if (s.charAt(i) > '9' || s.charAt(i) < '0') {
            return false;
        }
        num = num * 10 + (s.charAt(i) - '0');
        if (num > 255){
            return false;
        }
    }
    return true;
}
```
### 2、全排列
给定一个 没有重复 数字的序列，返回其所有可能的全排列。
示例:

- 输入: [1,2,3]
- 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]
```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合
    LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果
    public List<List<Integer>> permute(int[] nums) {
        if (nums.length == 0){
            return result;
        }
        boolean[] used = new boolean[nums.length];
        permuteHelper(nums, used);
        return result;
    }

    private void permuteHelper(int[] nums, boolean[] used){
        if (path.size() == nums.length){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++){
            //树枝去重
            if (used[i]){
                continue;
            }
            used[i] = true;
            path.add(nums[i]);
            permuteHelper(nums, used);
            path.removeLast();
            used[i] = false;
        }
    }
}
```
总结：排列问题与组合问题不同点

- 每层都是从0开始搜索而不是startIndex
- 需要used数组记录path里都放了哪些元素了
### 3、N皇后问题
与之前的解法一样，将二维矩阵抽象成一个树。
矩阵的高就相当于树的高度，也就是回溯的层数；矩阵的宽就相当于每个节点的宽度。
```java
private List<List<String>> result = new ArrayList<>();
public List<List<String>> solveNQueens(int n){
    char[][] chessBoard = new char[n][n];
    for (char[] chars : chessBoard) {
        Arrays.fill(chars, '.');
    }
    backTracking(n, 0, chessBoard);
    return result;
}

public void backTracking(int n, int row, char[][] chessBoard){
    if (row == n){
        result.add(charArray2List(chessBoard));
        return;
    }
    for (int col = 0; col < n; col++){
        if (isValid(n, row, col, chessBoard)){
            chessBoard[row][col] = 'Q';
            backTracking(n, row + 1, chessBoard);
            chessBoard[row][col] = '.';
        }
    }
}

//将二维字符数组转换为list
public List<String> charArray2List(char[][] chessBoard) {
    List<String> list = new ArrayList<>();
    for (char[] chars : chessBoard) {
        list.add(String.valueOf(chars));
    }
    return list;
}

public boolean isValid(int n, int row, int col, char[][] chessBoard){
    //检查该列是否符合要求
    for (int i = 0; i < row; i++){
        if (chessBoard[i][col] == 'Q'){
            return false;
        }
    }
    //不用检查行，因为在单层搜索的过程中，每一层递归只会选一行的一个元素
    //所以不用检查每行是否符合要求
    //检查对角线是否符合要求
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){
        if (chessBoard[i][j] == 'Q'){
            return false;
        }
    }
    //检查反对角线是否符合要求
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){
        if (chessBoard[i][j] == 'Q'){
            return false;
        }
    }
    return true;
}
```
### 4、解数独
难点就是二维递归
```java
public void solveSudoku(char[][] board) {
    backTracking(board);
}

public boolean backTracking(char[][] board){
    for(int i = 0; i < board.length; i++){
        for(int j = 0; j < board[0].length; j++){
            if(board[i][j] != '.'){
                continue;
            }
            for(char k = '1'; k <= '9'; k++){
                if(isValid(i, j, k, board)){
                    board[i][j] = k;
                    if(backTracking(board)){
                        return true;
                    }
                    board[i][j] = '.';
                }
            }
            return false;
        }
    }
    return true;
}

public boolean isValid(int row, int col, char k, char[][] board){
    //判断同行是否重复
    for(int i = 0; i < 9; i++){
        if(board[row][i] == k){
            return false;
        }
    }
    //判断同列是否重复
    for(int i = 0; i < 9; i++){
        if(board[i][col] == k){
            return false;
        }
    }
    //判断九宫格内是否有重复
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for(int i = startRow; i < startRow + 3; i++){
        for(int j = startCol; j < startCol + 3; j++){
            if(board[i][j] == k){
                return false;
            }
        }
    }
    return true;
}
```
本题不用考虑终止条件，解数独的题目遍历整个树形结构寻找可能的叶子结点就直接返回，不用和平常那样，找到所有的可能。
而且递归的下一层的棋盘一定比上一层多一个数，等数都填满了，递归自然就终止了。
# 二、贪心算法

**贪心的本质就是选择每一阶段的局部最优，从而达到全局最优。**

比如：有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？

指定每次拿最大的，最终结果就是拿走最大数额的钱。

每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。

## 2.1 什么时候用贪心？

**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。

**刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心**。

## 2.2 解题步骤

1. 将问题分解成若干子问题
2. 找出适合的贪心策略
3. 求解每个子问题的最优解
4. 将局部最优解堆叠成全局最优解







